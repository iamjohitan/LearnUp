import { Injectable, BadRequestException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { supabase } from '../supabase/supabase.client';
import axios from 'axios';
import * as crypto from 'crypto';

@Injectable()
export class AuthService {
  constructor(private jwtService: JwtService) {}

  // üîπ REGISTRO DE USUARIO
  async register(nombre: string, correo: string, password: string) {
    // 1Ô∏è‚É£ Validar dominio institucional
    if (!correo.endsWith('@usc.edu.co')) {
      throw new BadRequestException(
        'Solo se permiten correos pertenecientes a la USC',
      );
    }

    // 2Ô∏è‚É£ Validar que la contrase√±a sea fuerte
    if (password.length < 8) {
      throw new BadRequestException(
        'La contrase√±a debe tener al menos 8 caracteres',
      );
    }

    const weakPasswords = [
      '123456',
      'password',
      'qwerty',
      'abc123',
      'contrase√±a',
      '12345678',
      '111111',
    ];

    if (weakPasswords.includes(password.toLowerCase())) {
      throw new BadRequestException(
        'La contrase√±a es demasiado com√∫n o insegura',
      );
    }

    // Debe tener al menos una may√∫scula, una min√∫scula y un n√∫mero
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
    if (!passwordRegex.test(password)) {
      throw new BadRequestException(
        'La contrase√±a debe incluir al menos una may√∫scula, una min√∫scula y un n√∫mero',
      );
    }

    // 3Ô∏è‚É£ Verificar si la contrase√±a ha sido filtrada p√∫blicamente
    const sha1 = crypto
      .createHash('sha1')
      .update(password)
      .digest('hex')
      .toUpperCase();
    const prefix = sha1.slice(0, 5);
    const suffix = sha1.slice(5);

    const response = await axios.get(
      `https://api.pwnedpasswords.com/range/${prefix}`,
    );
    const lines = response.data.split('\n');
    const found = lines.some((line) => line.startsWith(suffix));

    if (found) {
      throw new BadRequestException(
        'Esta contrase√±a ha sido filtrada en bases de datos p√∫blicas. Por favor usa una m√°s segura.',
      );
    }

    // 4Ô∏è‚É£ Encriptar la contrase√±a antes de guardar
    const hash = await bcrypt.hash(password, 10);

    // 5Ô∏è‚É£ Insertar usuario en Supabase
    const { data, error } = await supabase
      .from('usuarios')
      .insert([{ nombre, correo, contrase√±a: hash }])
      .select();

    if (error) {
      throw new BadRequestException(
        `Error al registrar usuario: ${error.message}`,
      );
    }

    return { message: 'Usuario registrado correctamente ‚úÖ', data };
  }

  // üîπ LOGIN
  async login(correo: string, contrase√±a: string) {
    // Buscar usuario
    const { data, error } = await supabase
      .from('usuarios')
      .select('*')
      .eq('correo', correo)
      .single();

    if (error || !data) {
      throw new BadRequestException('Usuario no encontrado');
    }

    // Verificar contrase√±a
    const match = await bcrypt.compare(contrase√±a, data.contrase√±a);
    if (!match) {
      throw new BadRequestException('Contrase√±a incorrecta');
    }

    // Generar token JWT
    const token = this.jwtService.sign({
      id: data.id,
      correo: data.correo,
    });

    return { message: 'Login exitoso üéâ', token };
  }
}
